{"version":3,"sources":["System/TypeValidator.js","System/TypeValidator.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","areInvalid","d","Compare_1","areEqual","memberType","TypeInfoHelper","contains","Types_1","extends_1","__extends","_super","value","_this","this","call","_value","prototype","descriptor","Function","isFunction","Object","isObject","Array","isArray","String","isString","Number","isNumber","Boolean","isBoolean","type","isPrimitive","max","Math","min","length","i","targetKeys","keys","dKeys","_i","dKeys_1","key","indexOf","_a","dKeys_2","TypeInfo","TypeValidator","_typeDescriptor","freeze","isSubsetOf","o","t","defineProperty"],"mappings":";;;;CAIA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QAAoBG,UAANF,IAAiBF,OAAOC,QAAUC,OAElD,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,UAAW,YAAa,cAAeN,IAE1E,SAAUI,EAASF,GAClB,YC+FJ,SAAAM,GAAoBL,EAAOM,GAE1B,IAAIC,EAAAC,SAASR,EAAGM,GAChB,CACC,GAAIG,GAAa,GAAIC,GAAeV,EACpC,KAAIS,EAAWE,SAASL,GACvB,OAAO,EAET,OAAO,EA/FR,GAAAM,GAAAX,EAAuB,WACvBM,EAAAN,EAAuB,aACvBY,EAAAZ,EAA4B,cACtBa,EAAYD,EAAAA,WAGlBH,EAAA,SAAAK,GAKC,QAAAL,GAAYM,GALb,GAAAC,GAAAC,IAOEH,GAAAI,KAAAD,KAAMF,EAAO,WAAI,MAAAC,GAAKG,OAASJ,IAwEjC,MA/EoCF,GAAAJ,EAAAK,GAWnCL,EAAAW,UAAAV,SAAA,SAAsBW,GAGrB,GAAIN,GAAQE,KAAKE,MAEjB,IAAGJ,IAAQM,EACV,OAAO,CAER,QAAOA,GAEN,IAAKC,UACJ,MAAOL,MAAKM,UACb,KAAKC,QACJ,MAAOP,MAAKQ,QACb,KAAKC,OACJ,MAAOT,MAAKU,OACb,KAAKC,QACJ,MAAOX,MAAKY,QACb,KAAKC,QACJ,MAAOb,MAAKc,QACb,KAAKC,SACJ,MAAOf,MAAKgB,UAGd,GAAGhB,KAAKiB,YAAeb,IAAcJ,KAAKkB,cAAgB7B,EAAAC,SAASQ,EAAMM,GACxE,OAAO,CAGR,IAAGJ,KAAKU,SAAWD,MAAMC,QAAQN,GACjC,CAGC,IAAI,GAFAe,GAAMC,KAAKC,IAAIjB,EAAWkB,OAAQxB,EAAMwB,QAEpCC,EAAI,EAAKJ,EAAFI,EAAOA,IAErB,GAAGpC,EAAWW,EAAMyB,GAAInB,EAAWmB,IAClC,OAAO,CAGT,QAAO,EAGR,GAAGvB,KAAKQ,SACR,CACC,GAAIgB,GAAajB,OAAOkB,KAAK3B,GACzB4B,EAAQnB,OAAOkB,KAAKrB,EAGxB,IAAGsB,EAAMJ,OAAOE,EAAWF,OAC1B,OAAO,CAGR,KAAe,GAAAK,GAAA,EAAAC,EAAAF,EAAAC,EAAAC,EAAAN,OAAAK,IAAM,CAAjB,GAAIE,GAAGD,EAAAD,EAEV,IAA6B,IAA1BH,EAAWM,QAAQD,GACrB,OAAO,EAIT,IAAe,GAAAE,GAAA,EAAAC,EAAAN,EAAAK,EAAAC,EAAAV,OAAAS,IAAM,CAAjB,GAAIF,GAAGG,EAAAD,EAEV,IAAG5C,EAAWW,EAAM+B,GAAMzB,EAAWyB,IACpC,OAAO,GAIV,OAAO,GAGTrC,GA/EoCE,EAAAuC,SAAvBpD,GAAAW,eAAcA,CA4F3B,IAAA0C,GAAA,WACC,QAAAA,GAAoBC,GAAAnC,KAAAmC,gBAAAA,EACnB5B,OAAO6B,OAAOpC,MAOhB,MAJCkC,GAAA/B,UAAAkC,WAAA,SAAWC,GACV,GAAIC,GAAI,GAAI/C,GAAe8C,EAC3B,OAAOC,GAAE9C,SAASO,KAAKmC,kBAEzBD,IATarD,GAAAqD,cAAaA,EAW1B3B,OAAAiC,eAAA3D,EAAA,cAAAiB,OAAA,IDpCIjB,EAAAA,WCoCWqD","file":"System/TypeValidator.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT\n */\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", \"./Types\", \"./Compare\", \"../extends\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Types_1 = require(\"./Types\");\n    var Compare_1 = require(\"./Compare\");\n    var extends_1 = require(\"../extends\");\n    var __extends = extends_1.default;\n    var TypeInfoHelper = (function (_super) {\n        __extends(TypeInfoHelper, _super);\n        function TypeInfoHelper(value) {\n            var _this = this;\n            _super.call(this, value, function () { return _this._value = value; });\n        }\n        TypeInfoHelper.prototype.contains = function (descriptor) {\n            var value = this._value;\n            if (value === descriptor)\n                return true;\n            switch (descriptor) {\n                case Function:\n                    return this.isFunction;\n                case Object:\n                    return this.isObject;\n                case Array:\n                    return this.isArray;\n                case String:\n                    return this.isString;\n                case Number:\n                    return this.isNumber;\n                case Boolean:\n                    return this.isBoolean;\n            }\n            if (this.type != typeof descriptor || this.isPrimitive && !Compare_1.areEqual(value, descriptor))\n                return false;\n            if (this.isArray && Array.isArray(descriptor)) {\n                var max = Math.min(descriptor.length, value.length);\n                for (var i = 0; i < max; i++) {\n                    if (areInvalid(value[i], descriptor[i]))\n                        return false;\n                }\n                return true;\n            }\n            if (this.isObject) {\n                var targetKeys = Object.keys(value);\n                var dKeys = Object.keys(descriptor);\n                if (dKeys.length > targetKeys.length)\n                    return false;\n                for (var _i = 0, dKeys_1 = dKeys; _i < dKeys_1.length; _i++) {\n                    var key = dKeys_1[_i];\n                    if (targetKeys.indexOf(key) == -1)\n                        return false;\n                }\n                for (var _a = 0, dKeys_2 = dKeys; _a < dKeys_2.length; _a++) {\n                    var key = dKeys_2[_a];\n                    if (areInvalid(value[key], descriptor[key]))\n                        return false;\n                }\n            }\n            return true;\n        };\n        return TypeInfoHelper;\n    }(Types_1.TypeInfo));\n    exports.TypeInfoHelper = TypeInfoHelper;\n    function areInvalid(v, d) {\n        if (!Compare_1.areEqual(v, d)) {\n            var memberType = new TypeInfoHelper(v);\n            if (!memberType.contains(d))\n                return true;\n        }\n        return false;\n    }\n    var TypeValidator = (function () {\n        function TypeValidator(_typeDescriptor) {\n            this._typeDescriptor = _typeDescriptor;\n            Object.freeze(this);\n        }\n        TypeValidator.prototype.isSubsetOf = function (o) {\n            var t = new TypeInfoHelper(o);\n            return t.contains(this._typeDescriptor);\n        };\n        return TypeValidator;\n    }());\n    exports.TypeValidator = TypeValidator;\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = TypeValidator;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT\r\n */\r\n\r\n/**\r\n * A descriptor is simply a JSON tree that either has an actual value or a type that identifies what the expect type should be at that leaf in the tree.\r\n *\r\n * var descriptor = {\r\n *      a : Object,\r\n *      b : String,\r\n *      c : {\r\n *          d : true ,\r\n *          e : Array,\r\n *          f : []\r\n *      },\r\n *      g : \"literal\"\r\n * }\r\n */\r\n\r\nimport {TypeInfo} from \"./Types\";\r\nimport {areEqual} from \"./Compare\";\r\nimport __extendsImport from \"../extends\";\r\nconst __extends = __extendsImport;\r\n\r\n\r\nexport class TypeInfoHelper extends TypeInfo\r\n{\r\n\r\n\tprivate _value:any;\r\n\r\n\tconstructor(value:any)\r\n\t{\r\n\t\tsuper(value, ()=>this._value = value);\r\n\r\n\t}\r\n\r\n\tcontains<TDescriptor>(descriptor:any):this is TDescriptor\r\n\t{\r\n\r\n\t\tlet value = this._value;\r\n\r\n\t\tif(value===descriptor)\r\n\t\t\treturn true;\r\n\r\n\t\tswitch(descriptor)\r\n\t\t{\r\n\t\t\tcase Function:\r\n\t\t\t\treturn this.isFunction;\r\n\t\t\tcase Object:\r\n\t\t\t\treturn this.isObject;\r\n\t\t\tcase Array:\r\n\t\t\t\treturn this.isArray;\r\n\t\t\tcase String:\r\n\t\t\t\treturn this.isString;\r\n\t\t\tcase Number:\r\n\t\t\t\treturn this.isNumber;\r\n\t\t\tcase Boolean:\r\n\t\t\t\treturn this.isBoolean;\r\n\t\t}\r\n\r\n\t\tif(this.type != typeof descriptor || this.isPrimitive && !areEqual(value,descriptor))\r\n\t\t\treturn false;\r\n\r\n\t\t// Check array contents and confirm intersections.\r\n\t\tif(this.isArray && Array.isArray(descriptor))\r\n\t\t{\r\n\t\t\tlet max = Math.min(descriptor.length, value.length);\r\n\r\n\t\t\tfor(let i = 0; i<max; i++)\r\n\t\t\t{\r\n\t\t\t\tif(areInvalid(value[i], descriptor[i]))\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif(this.isObject)\r\n\t\t{\r\n\t\t\tlet targetKeys = Object.keys(value);\r\n\t\t\tlet dKeys = Object.keys(descriptor);\r\n\r\n\t\t\t// Quick check...\r\n\t\t\tif(dKeys.length>targetKeys.length)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t// Quick check #2...\r\n\t\t\tfor(let key of dKeys)\r\n\t\t\t{\r\n\t\t\t\tif(targetKeys.indexOf(key)== -1)\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Final pass with recursive...\r\n\t\t\tfor(let key of dKeys)\r\n\t\t\t{\r\n\t\t\t\tif(areInvalid(value[key], descriptor[key]))\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n}\r\n\r\nfunction areInvalid(v:any, d:any)\r\n{\r\n\tif(!areEqual(v, d))\r\n\t{\r\n\t\tlet memberType = new TypeInfoHelper(v);\r\n\t\tif(!memberType.contains(d))\r\n\t\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nexport class TypeValidator<T> {\r\n\tconstructor(private _typeDescriptor:any) {\r\n\t\tObject.freeze(this);\r\n\t}\r\n\r\n\tisSubsetOf(o:any):o is T {\r\n\t\tvar t = new TypeInfoHelper(o);\r\n\t\treturn t.contains(this._typeDescriptor);\r\n\t}\r\n}\r\n\r\nexport default TypeValidator;\r\n\r\n"]}