{"version":3,"sources":["System/Threading/Tasks/Parallel.js","System/Threading/Tasks/Parallel.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","extend","from","to","_i","_a","Object","keys","length","i","interact","w","onMessage","onError","message","onmessage","onerror","VOID0","postMessage","workers","Promise_1","Types_1","Worker_1","deferImmediate_1","Environment_1","ObjectPool_1","extends_1","__extends","MAX_WORKERS","URL","self","Type","UNDEFINED","webkitURL","_supports","isNodeJS","Worker","defaults","evalPath","__dirname","maxConcurrency","cpus","navigator","hardwareConcurrency","allowSynchronous","env","envNamespace","WorkerPromise","_super","worker","data","call","this","resolve","reject","response","e","Promise","getPool","key","pool","workerPools","ObjectPool","autoClearTimeout","recycle","k","__key","add","deferImmediate","terminate","tryGet","tryTake","getNew","url","dispose","Parallel","options","_requiredScripts","_requiredFunctions","ensureClampedMaxConcurrency","max","prototype","_getWorkerSource","task","scripts","functions","preStr","join","functions_1","name_1","name","fn","source","toString","JSON","stringify","ns","required","arguments","requireThese","required_1","a","STRING","push","FUNCTION","OBJECT","TypeError","_spawnWorker","src","Error","blob","Blob","type","createObjectURL","startNew","_","finallyThis","pipe","result","error_1","len_1","taskString","maxConcurrency_1","i_1","_loop_1","this_1","value","map","d","next","ii","p_1","wp_1","thenSynchronous","r","Math","min","state_1","PromiseCollection","console","warn","_this","slice","ArrayPromise","len","error","resolved","_loop_2","all","ii_1","wp_2","thenThis","state_2","fulfilled","defineProperty","get","enumerable","configurable"],"mappings":"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","file":"System/Threading/Tasks/Parallel.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n * Originally based upon Parallel.js: https://github.com/adambom/parallel.js/blob/master/lib/parallel.js\n */\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", \"../../Promises/Promise\", \"../../Types\", \"../Worker\", \"../deferImmediate\", \"../../Environment\", \"../../Disposable/ObjectPool\", \"../../../extends\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Promise_1 = require(\"../../Promises/Promise\");\n    var Types_1 = require(\"../../Types\");\n    var Worker_1 = require(\"../Worker\");\n    var deferImmediate_1 = require(\"../deferImmediate\");\n    var Environment_1 = require(\"../../Environment\");\n    var ObjectPool_1 = require(\"../../Disposable/ObjectPool\");\n    var extends_1 = require(\"../../../extends\");\n    var __extends = extends_1.default;\n    var MAX_WORKERS = 16, VOID0 = void 0, URL = typeof self !== Types_1.Type.UNDEFINED\n        ? (self.URL ? self.URL : self.webkitURL)\n        : null, _supports = (Environment_1.isNodeJS || self.Worker) ? true : false;\n    var defaults = {\n        evalPath: Environment_1.isNodeJS ? __dirname + '/eval.js' : null,\n        maxConcurrency: Environment_1.isNodeJS ? require('os').cpus().length : (navigator.hardwareConcurrency || 4),\n        allowSynchronous: true,\n        env: {},\n        envNamespace: 'env'\n    };\n    function extend(from, to) {\n        if (!to)\n            to = {};\n        for (var _i = 0, _a = Object.keys(from); _i < _a.length; _i++) {\n            var i = _a[_i];\n            if (to[i] === void 0)\n                to[i] = from[i];\n        }\n        return to;\n    }\n    function interact(w, onMessage, onError, message) {\n        if (onMessage)\n            w.onmessage = onMessage;\n        if (onError)\n            w.onerror = onError;\n        if (message !== VOID0)\n            w.postMessage(message);\n    }\n    var WorkerPromise = (function (_super) {\n        __extends(WorkerPromise, _super);\n        function WorkerPromise(worker, data) {\n            _super.call(this, function (resolve, reject) {\n                interact(worker, function (response) {\n                    resolve(response.data);\n                }, function (e) {\n                    reject(e);\n                }, data);\n            }, true);\n        }\n        return WorkerPromise;\n    }(Promise_1.Promise));\n    var workers;\n    (function (workers) {\n        function getPool(key) {\n            var pool = workerPools[key];\n            if (!pool) {\n                workerPools[key] = pool = new ObjectPool_1.ObjectPool(8);\n                pool.autoClearTimeout = 3000;\n            }\n            return pool;\n        }\n        var workerPools = {};\n        function recycle(w) {\n            if (w) {\n                w.onerror = null;\n                w.onmessage = null;\n                var k = w.__key;\n                if (k) {\n                    getPool(k).add(w);\n                }\n                else {\n                    deferImmediate_1.deferImmediate(function () { return w.terminate(); });\n                }\n            }\n            return null;\n        }\n        workers.recycle = recycle;\n        function tryGet(key) {\n            return getPool(key).tryTake();\n        }\n        workers.tryGet = tryGet;\n        function getNew(key, url) {\n            var worker = new Worker_1.default(url);\n            worker.__key = key;\n            worker.dispose = function () {\n                worker.onmessage = null;\n                worker.onerror = null;\n                worker.dispose = null;\n                worker.terminate();\n            };\n            return worker;\n        }\n        workers.getNew = getNew;\n    })(workers || (workers = {}));\n    var Parallel = (function () {\n        function Parallel(options) {\n            this.options = extend(defaults, options);\n            this._requiredScripts = [];\n            this._requiredFunctions = [];\n            this.ensureClampedMaxConcurrency();\n        }\n        Parallel.maxConcurrency = function (max) {\n            return new Parallel({ maxConcurrency: max });\n        };\n        Parallel.prototype._getWorkerSource = function (task, env) {\n            var scripts = this._requiredScripts, functions = this._requiredFunctions;\n            var preStr = '';\n            if (!Environment_1.isNodeJS && scripts.length) {\n                preStr += 'importScripts(\"' + scripts.join('\",\"') + '\");\\r\\n';\n            }\n            for (var _i = 0, functions_1 = functions; _i < functions_1.length; _i++) {\n                var _a = functions_1[_i], name_1 = _a.name, fn = _a.fn;\n                var source = fn.toString();\n                preStr += name_1\n                    ? \"var \" + name_1 + \" = \" + source + \";\"\n                    : source;\n            }\n            env = JSON.stringify(env || {});\n            var ns = this.options.envNamespace;\n            return preStr + (Environment_1.isNodeJS\n                ? \"process.on(\\\"message\\\", function(e) {global.\" + ns + \" = \" + env + \";process.send(JSON.stringify((\" + task.toString() + \")(JSON.parse(e).data)))})\"\n                : \"self.onmessage = function(e) {var global = {}; global.\" + ns + \" = \" + env + \"';self.postMessage((\" + task.toString() + \")(e.data))}\");\n        };\n        Parallel.prototype.require = function () {\n            var required = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                required[_i - 0] = arguments[_i];\n            }\n            return this.requireThese(required);\n        };\n        Parallel.prototype.requireThese = function (required) {\n            for (var _i = 0, required_1 = required; _i < required_1.length; _i++) {\n                var a = required_1[_i];\n                switch (typeof a) {\n                    case Types_1.Type.STRING:\n                        this._requiredScripts.push(a);\n                        break;\n                    case Types_1.Type.FUNCTION:\n                        this._requiredFunctions.push({ fn: a });\n                        break;\n                    case Types_1.Type.OBJECT:\n                        this._requiredFunctions.push(a);\n                        break;\n                    default:\n                        throw new TypeError(\"Invalid type.\");\n                }\n            }\n            return this;\n        };\n        Parallel.prototype._spawnWorker = function (task, env) {\n            var src = this._getWorkerSource(task, env);\n            if (Worker_1.default === VOID0)\n                return VOID0;\n            var worker = workers.tryGet(src);\n            if (worker)\n                return worker;\n            var scripts = this._requiredScripts, evalPath = this.options.evalPath;\n            if (!evalPath) {\n                if (Environment_1.isNodeJS)\n                    throw new Error(\"Can't use NodeJD without eval.js!\");\n                if (scripts.length)\n                    throw new Error(\"Can't use required scripts without eval.js!\");\n                if (!URL)\n                    throw new Error(\"Can't create a blob URL in this browser!\");\n            }\n            if (Environment_1.isNodeJS || scripts.length || !URL) {\n                worker = workers.getNew(src, evalPath);\n                worker.postMessage(src);\n            }\n            else if (URL) {\n                var blob = new Blob([src], { type: 'text/javascript' });\n                var url = URL.createObjectURL(blob);\n                worker = workers.getNew(src, url);\n            }\n            return worker;\n        };\n        Parallel.prototype.startNew = function (data, task, env) {\n            var _ = this;\n            var worker = _._spawnWorker(task, extend(_.options.env, env || {}));\n            if (worker)\n                return new WorkerPromise(worker, data)\n                    .finallyThis(function () { return workers.recycle(worker); });\n            if (_.options.allowSynchronous)\n                return new Promise_1.Promise(function (resolve, reject) {\n                    try {\n                        resolve(task(data));\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                });\n            throw new Error('Workers do not exist and synchronous operation not allowed!');\n        };\n        Parallel.prototype.pipe = function (data, task, env) {\n            var maxConcurrency = this.ensureClampedMaxConcurrency();\n            var result;\n            if (data && data.length) {\n                var len_1 = data.length;\n                var taskString = task.toString();\n                var maxConcurrency_1 = this.ensureClampedMaxConcurrency(), error_1;\n                var i_1 = 0;\n                var _loop_1 = function(w) {\n                    var worker = this_1._spawnWorker(taskString, env);\n                    if (!worker) {\n                        if (!this_1.options.allowSynchronous)\n                            throw new Error('Workers do not exist and synchronous operation not allowed!');\n                        return { value: Promise_1.Promise.map(data, task) };\n                    }\n                    if (!result) {\n                        result = data.map(function (d) { return new Promise_1.Promise(); });\n                    }\n                    var next = function () {\n                        if (error_1) {\n                            worker = workers.recycle(worker);\n                        }\n                        if (worker) {\n                            if (i_1 < len_1) {\n                                var ii = i_1++, p_1 = result[ii];\n                                var wp_1 = new WorkerPromise(worker, data[ii]);\n                                wp_1\n                                    .thenSynchronous(function (r) {\n                                    p_1.resolve(r);\n                                    next();\n                                }, function (e) {\n                                    if (!error_1) {\n                                        error_1 = e;\n                                        p_1.reject(e);\n                                        worker = workers.recycle(worker);\n                                    }\n                                })\n                                    .finallyThis(function () {\n                                    return wp_1.dispose();\n                                });\n                            }\n                            else {\n                                worker = workers.recycle(worker);\n                            }\n                        }\n                    };\n                    next();\n                };\n                var this_1 = this;\n                for (var w = 0; !error_1 && i_1 < Math.min(len_1, maxConcurrency_1); w++) {\n                    var state_1 = _loop_1(w);\n                    if (typeof state_1 === \"object\") return state_1.value;\n                }\n            }\n            return new Promise_1.PromiseCollection(result);\n        };\n        Parallel.prototype.ensureClampedMaxConcurrency = function () {\n            var maxConcurrency = this.options.maxConcurrency;\n            if (maxConcurrency > MAX_WORKERS) {\n                this.options.maxConcurrency = maxConcurrency = MAX_WORKERS;\n                console.warn(\"More than \" + MAX_WORKERS + \" workers can reach worker limits and cause unexpected results.  maxConcurrency reduced to \" + MAX_WORKERS + \".\");\n            }\n            return maxConcurrency;\n        };\n        Parallel.prototype.map = function (data, task, env) {\n            var _this = this;\n            if (!data || !data.length)\n                return Promise_1.ArrayPromise.fulfilled(data && []);\n            data = data.slice();\n            return new Promise_1.ArrayPromise(function (resolve, reject) {\n                var result = [], len = data.length;\n                result.length = len;\n                var taskString = task.toString();\n                var maxConcurrency = _this.ensureClampedMaxConcurrency(), error;\n                var i = 0, resolved = 0;\n                var _loop_2 = function(w) {\n                    var worker = _this._spawnWorker(taskString, env);\n                    if (!worker) {\n                        if (!_this.options.allowSynchronous)\n                            throw new Error('Workers do not exist and synchronous operation not allowed!');\n                        resolve(Promise_1.Promise.map(data, task).all());\n                        return { value: void 0 };\n                    }\n                    var next = function () {\n                        if (error) {\n                            worker = workers.recycle(worker);\n                        }\n                        if (worker) {\n                            if (i < len) {\n                                var ii_1 = i++;\n                                var wp_2 = new WorkerPromise(worker, data[ii_1]);\n                                wp_2\n                                    .thenSynchronous(function (r) {\n                                    result[ii_1] = r;\n                                    next();\n                                }, function (e) {\n                                    if (!error) {\n                                        error = e;\n                                        reject(e);\n                                        worker = workers.recycle(worker);\n                                    }\n                                })\n                                    .thenThis(function () {\n                                    resolved++;\n                                    if (resolved > len)\n                                        throw Error(\"Resolved count exceeds data length.\");\n                                    if (resolved === len)\n                                        resolve(result);\n                                })\n                                    .finallyThis(function () {\n                                    return wp_2.dispose();\n                                });\n                            }\n                            else {\n                                worker = workers.recycle(worker);\n                            }\n                        }\n                    };\n                    next();\n                };\n                for (var w = 0; !error && i < Math.min(len, maxConcurrency); w++) {\n                    var state_2 = _loop_2(w);\n                    if (typeof state_2 === \"object\") return state_2.value;\n                }\n            });\n        };\n        Object.defineProperty(Parallel, \"isSupported\", {\n            get: function () { return _supports; },\n            enumerable: true,\n            configurable: true\n        });\n        Parallel.options = function (options) {\n            return new Parallel(options);\n        };\n        Parallel.require = function () {\n            var required = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                required[_i - 0] = arguments[_i];\n            }\n            return (new Parallel()).requireThese(required);\n        };\n        Parallel.requireThese = function (required) {\n            return (new Parallel()).requireThese(required);\n        };\n        Parallel.startNew = function (data, task, env) {\n            return (new Parallel()).startNew(data, task, env);\n        };\n        Parallel.map = function (data, task, env) {\n            return (new Parallel()).map(data, task, env);\n        };\n        return Parallel;\n    }());\n    exports.Parallel = Parallel;\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = Parallel;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Originally based upon Parallel.js: https://github.com/adambom/parallel.js/blob/master/lib/parallel.js\r\n */\r\n\r\nimport {Promise, PromiseBase, ArrayPromise, PromiseCollection} from \"../../Promises/Promise\";\r\nimport {Type} from \"../../Types\";\r\nimport Worker from \"../Worker\";\r\nimport {WorkerLike} from \"../WorkerType\";\r\nimport {deferImmediate} from \"../deferImmediate\";\r\nimport {isNodeJS} from \"../../Environment\";\r\nimport {ObjectPool} from \"../../Disposable/ObjectPool\";\r\nimport {IMap} from \"../../Collections/Dictionaries/IDictionary\";\r\nimport __extendsImport from \"../../../extends\";\r\nconst __extends = __extendsImport;\r\n\r\ndeclare const navigator:any;\r\ndeclare const require:any;\r\ndeclare const self:any;\r\ndeclare const __dirname:string;\r\n\r\n//noinspection JSUnusedAssignment\r\nconst\r\n\tMAX_WORKERS:number = 16,\r\n\tVOID0:any          = void 0,\r\n\tURL                = typeof self!==Type.UNDEFINED\r\n\t\t? (self.URL ? self.URL : self.webkitURL)\r\n\t\t: null,\r\n\t_supports          = (isNodeJS || self.Worker) ? true : false; // node always supports parallel\r\n\r\nexport interface ParallelOptions\r\n{\r\n\t/**\r\n\t * This is the path to the file eval.js.  This is required when running in node, and required for some browsers (IE 10) in order to work around cross-domain restrictions for web workers.  Defaults to the same location as parallel.js in node environments, and null in the browser.\r\n\t **/\r\n\tevalPath?:string;\r\n\r\n\t/**\r\n\t * The maximum number of permitted worker threads.  This will default to 4, or the number of CPUs on your computer if you're running node.\r\n\t **/\r\n\tmaxConcurrency?:number;\r\n\r\n\t/**\r\n\t * If WebWorkers are not available, whether or not to fall back to synchronous processing using setTimeout.  Defaults to true.\r\n\t **/\r\n\tallowSynchronous?:boolean;\r\n\r\n\tenv?:any\r\n\tenvNamespace?:string\r\n}\r\n\r\n//noinspection JSUnusedAssignment\r\nconst defaults:ParallelOptions = {\r\n\tevalPath: isNodeJS ? __dirname + '/eval.js' : null,\r\n\tmaxConcurrency: isNodeJS ? require('os').cpus().length : (navigator.hardwareConcurrency || 4),\r\n\tallowSynchronous: true,\r\n\tenv: {},\r\n\tenvNamespace: 'env'\r\n};\r\n\r\nfunction extend<T extends any>(from:T, to:T):T\r\n{\r\n\tif(!to) to = <any>{};\r\n\tfor(var i of Object.keys(from))\r\n\t{\r\n\t\tif(to[i]=== void 0) to[i] = from[i];\r\n\t}\r\n\treturn to;\r\n}\r\n\r\nfunction interact(\r\n\tw:WorkerLike,\r\n\tonMessage:(msg:{data:any})=>void,\r\n\tonError:(e:any)=>void,\r\n\tmessage?:any):void\r\n{\r\n\tif(onMessage) w.onmessage = onMessage;\r\n\tif(onError) w.onerror = onError;\r\n\tif(message!==VOID0) w.postMessage(message);\r\n}\r\n\r\nclass WorkerPromise<T> extends Promise<T>\r\n{\r\n\tconstructor(worker:WorkerLike, data:any)\r\n\t{\r\n\t\tsuper((resolve, reject)=>\r\n\t\t{\r\n\t\t\tinteract(\r\n\t\t\t\tworker,\r\n\t\t\t\t(response:{data:any})=>\r\n\t\t\t\t{\r\n\t\t\t\t\tresolve(response.data);\r\n\t\t\t\t},\r\n\t\t\t\t(e:any)=>\r\n\t\t\t\t{\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t},\r\n\t\t\t\tdata)\r\n\t\t}, true);\r\n\t}\r\n}\r\n\r\nexport type RequireType = string | Function | {name?:string,fn:Function};\r\n\r\nmodule workers\r\n{\r\n\r\n\t/*\r\n\t * Note:\r\n\t * Currently there is nothing preventing excessive numbers of workers from being generated.\r\n\t * Eventually there will be a master pool count which will regulate these workers.\r\n\t */\r\n\r\n\tfunction getPool(key:string):ObjectPool<WorkerLike>\r\n\t{\r\n\t\tvar pool = workerPools[key];\r\n\t\tif(!pool)\r\n\t\t{\r\n\t\t\tworkerPools[key] = pool = new ObjectPool<WorkerLike>(8);\r\n\t\t\tpool.autoClearTimeout = 3000; // Fast cleanup... 1s.\r\n\t\t}\r\n\t\treturn pool;\r\n\t}\r\n\r\n\tvar workerPools:IMap<ObjectPool<WorkerLike>> = {};\r\n\r\n\texport function recycle(w:WorkerLike):WorkerLike\r\n\t{ // always returns null.\r\n\t\tif(w)\r\n\t\t{\r\n\t\t\tw.onerror = null;\r\n\t\t\tw.onmessage = null;\r\n\t\t\tvar k = (<any>w).__key;\r\n\t\t\tif(k)\r\n\t\t\t{\r\n\t\t\t\tgetPool(k).add(w);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tdeferImmediate(()=>w.terminate());\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\texport function tryGet(key:string):WorkerLike\r\n\t{\r\n\t\treturn getPool(key).tryTake();\r\n\t}\r\n\r\n\texport function getNew(key:string, url:string):WorkerLike\r\n\t{\r\n\t\tvar worker:any = new Worker(url);\r\n\t\tworker.__key = key;\r\n\t\tworker.dispose = ()=>\r\n\t\t{\r\n\t\t\tworker.onmessage = null;\r\n\t\t\tworker.onerror = null;\r\n\t\t\tworker.dispose = null;\r\n\t\t\tworker.terminate();\r\n\t\t};\r\n\t\treturn worker;\r\n\t}\r\n}\r\n\r\n\r\nexport class Parallel\r\n{\r\n\r\n\toptions:ParallelOptions;\r\n\t_requiredScripts:string[];\r\n\t_requiredFunctions:{name?:string,fn:Function}[];\r\n\r\n\tconstructor(options?:ParallelOptions)\r\n\t{\r\n\t\tthis.options = extend(defaults, options);\r\n\t\tthis._requiredScripts = [];\r\n\t\tthis._requiredFunctions = [];\r\n\r\n\t\tthis.ensureClampedMaxConcurrency();\r\n\t}\r\n\r\n\tstatic maxConcurrency(max:number):Parallel\r\n\t{\r\n\t\treturn new Parallel({maxConcurrency: max});\r\n\t}\r\n\r\n\tprotected _getWorkerSource(task:Function|string, env?:any):string\r\n\t{\r\n\t\tvar scripts = this._requiredScripts, functions = this._requiredFunctions;\r\n\t\tvar preStr = '';\r\n\r\n\t\tif(!isNodeJS && scripts.length)\r\n\t\t{\r\n\t\t\tpreStr += 'importScripts(\"' + scripts.join('\",\"') + '\");\\r\\n';\r\n\t\t}\r\n\r\n\t\tfor(let {name, fn} of functions)\r\n\t\t{\r\n\t\t\tvar source = fn.toString();\r\n\t\t\tpreStr += name\r\n\t\t\t\t? `var ${name} = ${source};`\r\n\t\t\t\t: source;\r\n\t\t}\r\n\r\n\r\n\t\tenv = JSON.stringify(env || {});\r\n\r\n\t\tconst ns = this.options.envNamespace;\r\n\r\n\t\treturn preStr + (\r\n\t\t\t\tisNodeJS\r\n\t\t\t\t\t? `process.on(\"message\", function(e) {global.${ns} = ${env};process.send(JSON.stringify((${task.toString()})(JSON.parse(e).data)))})`\r\n\t\t\t\t\t: `self.onmessage = function(e) {var global = {}; global.${ns} = ${env}';self.postMessage((${task.toString()})(e.data))}`\r\n\t\t\t);\r\n\t}\r\n\r\n\trequire(...required:RequireType[]):this\r\n\t{\r\n\t\treturn this.requireThese(required);\r\n\t}\r\n\r\n\trequireThese(required:RequireType[]):this\r\n\t{\r\n\t\tfor(let a of required)\r\n\t\t{\r\n\t\t\tswitch(typeof a)\r\n\t\t\t{\r\n\t\t\t\tcase Type.STRING:\r\n\t\t\t\t\tthis._requiredScripts.push(<string>a);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase Type.FUNCTION:\r\n\t\t\t\t\tthis._requiredFunctions.push({fn: <Function>a});\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase Type.OBJECT:\r\n\t\t\t\t\tthis._requiredFunctions.push(<{name?:string,fn:Function}>a);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new TypeError(\"Invalid type.\");\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\r\n\tprotected _spawnWorker(task:Function|string, env?:any):WorkerLike\r\n\t{\r\n\t\tvar src = this._getWorkerSource(task, env);\r\n\r\n\t\tif(Worker===VOID0) return VOID0;\r\n\t\tvar worker = workers.tryGet(src);\r\n\t\tif(worker) return worker;\r\n\r\n\t\tvar scripts = this._requiredScripts, evalPath = this.options.evalPath;\r\n\r\n\t\tif(!evalPath)\r\n\t\t{\r\n\t\t\tif(isNodeJS)\r\n\t\t\t\tthrow new Error(\"Can't use NodeJD without eval.js!\");\r\n\t\t\tif(scripts.length)\r\n\t\t\t\tthrow new Error(\"Can't use required scripts without eval.js!\");\r\n\t\t\tif(!URL)\r\n\t\t\t\tthrow new Error(\"Can't create a blob URL in this browser!\");\r\n\t\t}\r\n\r\n\t\tif(isNodeJS || scripts.length || !URL)\r\n\t\t{\r\n\t\t\tworker = workers.getNew(src, evalPath);\r\n\t\t\tworker.postMessage(src);\r\n\t\t}\r\n\t\telse if(URL)\r\n\t\t{\r\n\t\t\tvar blob = new Blob([src], {type: 'text/javascript'});\r\n\t\t\tvar url = URL.createObjectURL(blob);\r\n\r\n\t\t\tworker = workers.getNew(src, url);\r\n\t\t}\r\n\r\n\t\treturn worker;\r\n\t}\r\n\r\n\tstartNew<T,U>(data:T, task:(data:T) => U, env?:any):Promise<U>\r\n\t{\r\n\t\tconst _ = this;\r\n\r\n\t\tlet worker = _._spawnWorker(task, extend(_.options.env, env || {}));\r\n\t\tif(worker)\r\n\t\t\treturn new WorkerPromise<U>(worker, data)\r\n\t\t\t\t.finallyThis(()=>workers.recycle(worker));\r\n\r\n\t\tif(_.options.allowSynchronous)\r\n\t\t\treturn new Promise<U>(\r\n\t\t\t\t(resolve, reject)=>\r\n\t\t\t\t{\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresolve(task(data));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch(e)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\tthrow new Error('Workers do not exist and synchronous operation not allowed!');\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an array of promises that each resolve after their task completes.\r\n\t * Provides a potential performance benefit by not waiting for all promises to resolve before proceeding to next step.\r\n\t * @param data\r\n\t * @param task\r\n\t * @param env\r\n\t * @returns {PromiseCollection}\r\n\t */\r\n\tpipe<T,U>(data:T[], task:(data:T) => U, env?:any):PromiseCollection<U>\r\n\t{\r\n\t\tlet maxConcurrency = this.ensureClampedMaxConcurrency();\r\n\r\n\t\t// The resultant promise collection will make an internal copy...\r\n\t\tvar result:Promise<U>[];\r\n\r\n\t\tif(data && data.length)\r\n\t\t{\r\n\t\t\tconst len = data.length;\r\n\t\t\tconst taskString = task.toString();\r\n\t\t\tlet maxConcurrency = this.ensureClampedMaxConcurrency(), error:any;\r\n\t\t\tlet i = 0;\r\n\t\t\tfor(let w = 0; !error && i<Math.min(len, maxConcurrency); w++)\r\n\t\t\t{\r\n\t\t\t\tlet worker = this._spawnWorker(taskString, env);\r\n\r\n\t\t\t\tif(!worker)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(!this.options.allowSynchronous)\r\n\t\t\t\t\t\tthrow new Error('Workers do not exist and synchronous operation not allowed!');\r\n\r\n\t\t\t\t\t// Concurrency doesn't matter in a single thread... Just queue it all up.\r\n\t\t\t\t\treturn Promise.map(data, task);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(!result)\r\n\t\t\t\t{\r\n\t\t\t\t\t// There is a small risk that the consumer could call .resolve() which would result in a double resolution.\r\n\t\t\t\t\t// But it's important to minimize the number of objects created.\r\n\t\t\t\t\tresult = data.map(d=>new Promise<U>());\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet next = ()=>\r\n\t\t\t\t{\r\n\t\t\t\t\tif(error)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tworker = workers.recycle(worker);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(worker)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(i<len)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t//noinspection JSReferencingMutableVariableFromClosure\r\n\t\t\t\t\t\t\tlet ii = i++, p = result[ii];\r\n\t\t\t\t\t\t\tlet wp = new WorkerPromise<U>(worker, data[ii]);\r\n\t\t\t\t\t\t\twp\r\n\t\t\t\t\t\t\t\t.thenSynchronous(r=>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tp.resolve(r);\r\n\t\t\t\t\t\t\t\t\tnext();\r\n\t\t\t\t\t\t\t\t}, e=>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tif(!error)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\terror = e;\r\n\t\t\t\t\t\t\t\t\t\tp.reject(e);\r\n\t\t\t\t\t\t\t\t\t\tworker = workers.recycle(worker);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t.finallyThis(()=>\r\n\t\t\t\t\t\t\t\t\twp.dispose());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tworker = workers.recycle(worker);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\tnext();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn new PromiseCollection(result);\r\n\t}\r\n\r\n\tprivate ensureClampedMaxConcurrency():number\r\n\t{\r\n\t\tlet {maxConcurrency} = this.options;\r\n\t\tif(maxConcurrency>MAX_WORKERS)\r\n\t\t{\r\n\t\t\tthis.options.maxConcurrency = maxConcurrency = MAX_WORKERS;\r\n\t\t\tconsole.warn(`More than ${MAX_WORKERS} workers can reach worker limits and cause unexpected results.  maxConcurrency reduced to ${MAX_WORKERS}.`);\r\n\t\t}\r\n\t\treturn maxConcurrency;\r\n\t}\r\n\r\n\t/**\r\n\t * Waits for all tasks to resolve and returns a promise with the results.\r\n\t * @param data\r\n\t * @param task\r\n\t * @param env\r\n\t * @returns {ArrayPromise}\r\n\t */\r\n\tmap<T,U>(data:T[], task:(data:T) => U, env?:any):ArrayPromise<U>\r\n\t{\r\n\t\tif(!data || !data.length)\r\n\t\t\treturn ArrayPromise.fulfilled(data && []);\r\n\r\n\t\t// Would return the same result, but has extra overhead.\r\n\t\t// return this.pipe(data,task).all();\r\n\r\n\t\tdata = data.slice(); // Never use the original.\r\n\t\treturn new ArrayPromise<U>((resolve, reject)=>\r\n\t\t{\r\n\t\t\tconst result:U[] = [], len = data.length;\r\n\t\t\tresult.length = len;\r\n\r\n\t\t\tconst taskString = task.toString();\r\n\t\t\tlet maxConcurrency = this.ensureClampedMaxConcurrency(), error:any;\r\n\t\t\tlet i = 0, resolved = 0;\r\n\t\t\tfor(let w = 0; !error && i<Math.min(len, maxConcurrency); w++)\r\n\t\t\t{\r\n\t\t\t\tlet worker = this._spawnWorker(taskString, env);\r\n\r\n\t\t\t\tif(!worker)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(!this.options.allowSynchronous)\r\n\t\t\t\t\t\tthrow new Error('Workers do not exist and synchronous operation not allowed!');\r\n\r\n\t\t\t\t\t// Concurrency doesn't matter in a single thread... Just queue it all up.\r\n\t\t\t\t\tresolve(Promise.map(data, task).all());\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet next = ()=>\r\n\t\t\t\t{\r\n\t\t\t\t\tif(error)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tworker = workers.recycle(worker);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(worker)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(i<len)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet ii = i++;\r\n\t\t\t\t\t\t\tlet wp = new WorkerPromise<U>(worker, data[ii]);\r\n\t\t\t\t\t\t\twp\r\n\t\t\t\t\t\t\t\t.thenSynchronous(r=>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tresult[ii] = r;\r\n\t\t\t\t\t\t\t\t\tnext();\r\n\t\t\t\t\t\t\t\t}, e=>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tif(!error)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\terror = e;\r\n\t\t\t\t\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t\t\t\t\t\tworker = workers.recycle(worker);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t.thenThis(()=>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tresolved++;\r\n\t\t\t\t\t\t\t\t\tif(resolved>len) throw Error(\"Resolved count exceeds data length.\");\r\n\t\t\t\t\t\t\t\t\tif(resolved===len) resolve(result);\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t.finallyThis(()=>\r\n\t\t\t\t\t\t\t\t\twp.dispose());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tworker = workers.recycle(worker);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\tnext();\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\t}\r\n\r\n\tstatic get isSupported() { return _supports; }\r\n\r\n\tstatic options(options?:ParallelOptions):Parallel\r\n\t{\r\n\t\treturn new Parallel(options);\r\n\t}\r\n\r\n\tstatic require(...required:RequireType[]):Parallel\r\n\t{\r\n\t\treturn (new Parallel()).requireThese(required)\r\n\t}\r\n\r\n\tstatic requireThese(required:RequireType[]):Parallel\r\n\t{\r\n\t\treturn (new Parallel()).requireThese(required)\r\n\t}\r\n\r\n\tstatic startNew<T,U>(data:T, task:(data:T) => U, env?:any):PromiseBase<U>\r\n\t{\r\n\t\treturn (new Parallel()).startNew(data, task, env);\r\n\t}\r\n\r\n\t//\r\n\t// forEach<T>(data:T[], task:(data:T) => void, env?:any):PromiseBase<void>\r\n\t// {}\r\n\r\n\tstatic map<T,U>(data:T[], task:(data:T) => U, env?:any):ArrayPromise<U>\r\n\t{\r\n\t\treturn (new Parallel()).map(data, task, env);\r\n\t}\r\n}\r\n\r\n//\r\n//\r\n// \tprivate _spawnReduceWorker<N>(\r\n// \t\tdata:any,\r\n// \t\tcb:(data:N) => N,\r\n// \t\tdone:(err?:any, wrk?:WorkerLike)=>void,\r\n// \t\tenv?:any,\r\n// \t\twrk?:WorkerLike)\r\n// \t{\r\n// \t\tconst _ = this;\r\n// \t\tif(!wrk) wrk = _._spawnWorker(cb, env);\r\n//\r\n// \t\tif(wrk!==VOID0)\r\n// \t\t{\r\n// \t\t\tinteract(wrk,\r\n// \t\t\t\tmsg=>\r\n// \t\t\t\t{\r\n// \t\t\t\t\t_.data[_.data.length] = msg.data;\r\n// \t\t\t\t\tdone(null, wrk);\r\n// \t\t\t\t},\r\n// \t\t\t\te=>\r\n// \t\t\t\t{\r\n// \t\t\t\t\twrk.terminate();\r\n// \t\t\t\t\tdone(e, null);\r\n// \t\t\t\t},\r\n// \t\t\t\tdata);\r\n// \t\t}\r\n// \t\telse if(_.options.allowSynchronous)\r\n// \t\t{\r\n// \t\t\tdeferImmediate(()=>\r\n// \t\t\t{\r\n// \t\t\t\t_.data[_.data.length] = cb(data);\r\n// \t\t\t\tdone();\r\n// \t\t\t});\r\n// \t\t}\r\n// \t\telse\r\n// \t\t{\r\n// \t\t\tthrow new Error('Workers do not exist and synchronous operation not allowed!');\r\n// \t\t}\r\n// \t}\r\n//\r\n//\r\n//\r\n//\r\n// \treduce<N>(cb:(data:N[]) => N, env?:any):Parallel<T>\r\n// \t{\r\n// \t\tenv = extend(this.options.env, env || {});\r\n//\r\n// \t\tvar runningWorkers = 0;\r\n// \t\tconst _ = this;\r\n//\r\n//\r\n// \t\t_._operation = new Promise<any>((resolve, reject)=>\r\n// \t\t{\r\n//\r\n// \t\t\tconst done = (err?:any, wrk?:WorkerLike)=>\r\n// \t\t\t{\r\n// \t\t\t\t--runningWorkers;\r\n// \t\t\t\tif(err)\r\n// \t\t\t\t{\r\n// \t\t\t\t\treject(err);\r\n// \t\t\t\t}\r\n// \t\t\t\telse if(_.data.length===1 && runningWorkers===0)\r\n// \t\t\t\t{\r\n// \t\t\t\t\tresolve(_.data = _.data[0]);\r\n// \t\t\t\t\tif(wrk) wrk.terminate();\r\n// \t\t\t\t}\r\n// \t\t\t\telse if(_.data.length>1)\r\n// \t\t\t\t{\r\n// \t\t\t\t\t++runningWorkers;\r\n// \t\t\t\t\t_._spawnReduceWorker([_.data[0], _.data[1]], cb, done, env, wrk);\r\n// \t\t\t\t\t_.data.splice(0, 2);\r\n// \t\t\t\t}\r\n// \t\t\t\telse\r\n// \t\t\t\t{\r\n// \t\t\t\t\tif(wrk) wrk.terminate();\r\n// \t\t\t\t}\r\n// \t\t\t};\r\n//\r\n// \t\t\tif(_.data.length===1)\r\n// \t\t\t{\r\n// \t\t\t\tresolve(_.data[0]);\r\n// \t\t\t}\r\n// \t\t\telse\r\n// \t\t\t{\r\n// \t\t\t\tfor(var i = 0; i<_.options.maxConcurrency && i<Math.floor(_.data.length/2); ++i)\r\n// \t\t\t\t{\r\n// \t\t\t\t\t++runningWorkers;\r\n// \t\t\t\t\t_._spawnReduceWorker([_.data[i*2], _.data[i*2 + 1]], cb, done, env);\r\n// \t\t\t\t}\r\n//\r\n// \t\t\t\t_.data.splice(0, i*2);\r\n// \t\t\t}\r\n// \t\t}, true);\r\n// \t\treturn this;\r\n//\r\n// \t}\r\n\r\n\r\nexport default Parallel;\r\n"]}